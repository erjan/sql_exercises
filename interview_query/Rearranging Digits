Given a string n, a multi-digit number, write a function rearranging_digits to return a string of the smallest number larger than n that can be created by rearranging the digits in n. Return None if no such number exists.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

To understand the solution, we need to understand its logic.

From the question, we can make some observations. 1. We need a bigger number than the number we have.

Also, this number must be the smallest.
Here’s an idea: we can generate all possible numbers from the digits in n, then we can get all bigger ones than n and choose the smallest.

So for example if n = 395 then we generate 395 , 935 , 953 , 593 , 539 , 359 .

Then we collect one bigger one: 935, 953, 593, 539.

This solution will work, but generating all these permutations is very time and space-intensive (time and space complexity of 
�
(
�
!
)
O(n!)).

So we will need to try a better approach by carefully examining the problem.

If we have n sorted Descending, we can`t make it any bigger, and we are done.

Another example n = 356421 the answer will be 365421, generated by four steps.

divide the first part 35 from sorted descending part 6421.

get the least number of the first part, 5, replace it with the biggest number from the sorted part 6421 which is 6 then we would have the two parts 36 and 5432.

sort the second part ascending to be 2345.

append the two parts together to have finally the result 365421.

The final code:

def rearranging_digits(n):
    def just_bigger(target_digit, remaining_digits):
        next_digit = max(remaining_digits)
        for num in remaining_digits:
            if num > target_digit and num < next_digit:
                next_digit = num
        return next_digit

    #Holds all digits 
    total_digits = [int(str_digit) for str_digit in n] 

    #the first portion, starts empty
    have_digits = []

    #The ramining prtion, stated with all digits
    remaining_digits = total_digits.copy()
    

    for _ in range(len(total_digits)):
        #Generate the Descending sorted from the reamining digits
        desc_digits = sorted(remaining_digits, reverse=True)

        if remaining_digits == desc_digits:
            if len(have_digits) == 0:
                return None
            else:
                #if the remaining digits is sorted in Descending order we swap the least digit with the smallets digit larger than that digit.
                have_digits[-1], moved_digit = just_bigger(have_digits[-1],
                                                           remaining_digits), have_digits[-1]
                remaining_digits.remove(have_digits[-1])
                remaining_digits.append(moved_digit)
                return ''.join(map(str, have_digits)) + ''.join(map(str, sorted(remaining_digits)))

        have_digits.append(remaining_digits[0])
        del remaining_digits[0]
